<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on TenderMint</title>
    <link>http://tendermint.com/posts/</link>
    <description>Recent content in Posts on TenderMint</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 13 Sep 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://tendermint.com/posts/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Cases for Tendermint</title>
      <link>http://tendermint.com/posts/cases-for-tendermint/</link>
      <pubDate>Sun, 13 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tendermint.com/posts/cases-for-tendermint/</guid>
      <description>

&lt;p&gt;&lt;br/&gt;
I got a great piece of feedback yesterday.  I was explaining to someone whether a blockchain application should be built on the
EVM or as a native transaction type in Tendermint.  After doing so, the feedback that I got was &amp;ldquo;You should be blogging about this stuff, Tendermint doesn’t have enough marketing / explanation of how it fits into the ecosystem.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re going to fix that starting today.&lt;/p&gt;

&lt;p&gt;You may have an application that benefits from blockchain technology, and you may be trying to figure out whether to build that on Bitcoin, some meta-coin protocol like Counterparty, with Solidity/Serpent on the Ethereum virtual machine, or on a new blockchain stack altogether.  This blog post will attempt to demonstrate why you should seriously consider building on Tendermint.&lt;/p&gt;

&lt;h2 id=&#34;a-little-background-on-tendermint:1825e1740a61156b2d6c2c2a5daacec7&#34;&gt;A little background on Tendermint&lt;/h2&gt;

&lt;p&gt;Tendermint is not a fork of Bitcoin, NXT, Ripple, or Ethereum.  Tendermint is its own blockchain stack written from the ground up in a very opinionated fashion.  It started back in 2014 as an ambitious project to solve the Bitcoin mining problem and bring real Byzantine fault tolerant consensus to cryptocurrencies.  First we adapted an existing BGA consensus algorithm to make it suitable for blockchains.  Next for the actual implementation we considered forking Bitcoin, NXT, BitShares, and other projects, but none could easily accomodate the desired project architecture.  So, a brand spanking new blockchain stack was born.&lt;/p&gt;

&lt;p&gt;Tendermint offers:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Byzantine fault tolerant consensus with unparalleled speed and security guarantees &amp;ndash; without mining.&lt;/li&gt;
&lt;li&gt;A very clean codebase with clear separation of concerns &amp;ndash; no spaghetti, thanks Golang!&lt;/li&gt;
&lt;li&gt;Throttled/fair P2P stack to handle multiplexed channels of communication.&lt;/li&gt;
&lt;li&gt;Clear p2p logic with the reactor pattern&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;On top of this framework, we&amp;rsquo;ve built more advanced blockchain features.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A compatible and efficient Ethereum VM implementation&lt;/li&gt;
&lt;li&gt;A permissions system that works across accounts and VM contracts&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We&amp;rsquo;re going to build more exciting features going forward, except this time we&amp;rsquo;ll blog about it while we do it, so hang on to your metaphorical horses, this will get interesting.  By the way, if you go to &lt;a href=&#34;http://tendermint.com&#34;&gt;http://tendermint.com&lt;/a&gt; and sign up for the newsletter, we&amp;rsquo;ll
send you an email with every published blog post.&lt;/p&gt;

&lt;h2 id=&#34;on-tendermint-consensus:1825e1740a61156b2d6c2c2a5daacec7&#34;&gt;On Tendermint consensus&lt;/h2&gt;

&lt;p&gt;The consensus system is the foundational layer of any blockchain stack. It is the process by which all of the transaction validators (aka miners) agree on the state of the network.  Improvements in speed, security, and cost of a consensus system ripple up and improve performance of any networks &amp;amp; applications built on top of it.  Lets dive into some examples to get a sense of how it works.&lt;/p&gt;

&lt;h3 id=&#34;case-1-payment-verification:1825e1740a61156b2d6c2c2a5daacec7&#34;&gt;Case 1: Payment verification&lt;/h3&gt;

&lt;p&gt;Say that you&amp;rsquo;re in a room and your mobile phone is connected to untrusted wifi, and you&amp;rsquo;re making a business deal with Satoshi.  Satoshi just sent you a large payment, and you need to verify that this payment was committed onto the blockchain network irreversibly.&lt;/p&gt;

&lt;p&gt;With Bitcoin, you generally need to wait up to 6 confirmation blocks (about 1 hour, sometimes longer) to consider a transaction fully committed.  For very large payment transactions you should wait even longer, because the security afforded by the blockchain miners is no greater than the cost of double-spending that transaction, which is today only about 25 Bitcoins per reverted block, and soon to be half of that.&lt;/p&gt;

&lt;p&gt;With Tendermint, a global network of 1000 independent validators can commit a transaction in less than 60 seconds, though this is a very conservative estimate and can probably be much faster; and it only gets faster with increased bandwidth and computational capacity of each node.  In the near future we&amp;rsquo;ll be able to commit transactions on a global Tendermint blockchain with more than 1000 validators in a matter of seconds &amp;ndash; the only real limitation is the speed of light.&lt;/p&gt;

&lt;h3 id=&#34;case-2-name-registry-lookup:1825e1740a61156b2d6c2c2a5daacec7&#34;&gt;Case 2: Name registry lookup&lt;/h3&gt;

&lt;p&gt;Say that you&amp;rsquo;re in the same room with Satoshi, but instead of verifying a payment, you need to verify Satoshi&amp;rsquo;s public key as registered under the name &amp;ldquo;@satoshi&amp;rdquo; on a name-registry blockchain.  The main difference here is that you&amp;rsquo;re looking to verify the current value of a pre-existing value on the blockchain-derived name-registry state.&lt;/p&gt;

&lt;p&gt;With Bitcoin (and Namecoin), you can verify that &amp;ldquo;@satoshi&amp;rdquo; was registered with a particular public key at some point in the past, but you wouldn&amp;rsquo;t know whether the public key had been updated because Bitcoin (and Namecoin) doesn&amp;rsquo;t support balanced merkle trees on the state derived from the blockchain.  In Namecoin you can check that a transaction was included in the blockchain, but you cannot efficiently check for the exclusion of updates that may follow without downloading the entire blockchain.  Even if Bitcoin/Namecoin did support balanced merkle trees on name-registry state, you would still have to download and verify all the blockchain hashes and headers, and if the value might have been updated recently you&amp;rsquo;re still vulnerable to a fork-censorship attack.&lt;/p&gt;

&lt;p&gt;With Tendermint, all you need is the most recent blockhash signed by more than &lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt; of the validators, and a merkle proof that proves the current value associated with the name &amp;ldquo;@staoshi&amp;rdquo;.  You don&amp;rsquo;t even need to wait for a single commit.  If you&amp;rsquo;re interested, see &lt;a href=&#34;https://github.com/tendermint/tendermint/wiki/Merkle-Trees#iavl-tree&#34;&gt;https://github.com/tendermint/tendermint/wiki/Merkle-Trees#iavl-tree&lt;/a&gt; for more information on our balanced binary merkle tree implementation.&lt;/p&gt;

&lt;p&gt;In future posts we&amp;rsquo;ll go into detail about the consensus algorithm and how it can provide these unique speed &amp;amp; security guarantees without proof-of-work mining.  For now, you can check the most recent Tendermint spec on the github wiki here: &lt;a href=&#34;https://github.com/tendermint/tendermint/&#34;&gt;https://github.com/tendermint/tendermint/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;tendermint-architecture:1825e1740a61156b2d6c2c2a5daacec7&#34;&gt;Tendermint architecture&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://tendermint.com/images/tm_architecture.png&#34;/&gt;&lt;/p&gt;

&lt;p&gt;The above diagram is meant to show that:
 * the consensus and tx-execution modules are separate except for the shared (immutable/merkle-ized) state.
 * the consensus module takes a block, a commit for the block, and the last state and uses the tx-execution module to produce the next state.
 * the VM call transaction is one of many transaction types offered by the tx-execution module.
 * the Ethereum VM (EVM) is only one of potentially many supported virtual machines.
 * the next state is completely determined by the old state and the transactions in a block.&lt;/p&gt;

&lt;p&gt;So, if you have a blockchain application in mind, on Tendermint there are two options to consider &amp;ndash; a smart contract on the Ethereum VM (and in the future, other VMs as well), or, a native transaction type (like SendTx or NameTx above).&lt;/p&gt;

&lt;h2 id=&#34;whether-to-develop-a-vm-smart-contract-or-develop-a-native-tendermint-contract:1825e1740a61156b2d6c2c2a5daacec7&#34;&gt;Whether to develop a VM smart contract or develop a native Tendermint contract&lt;/h2&gt;

&lt;p&gt;The main benefit of a turing-complete VM on a blockchain is that potentially anyone can upload new contract logic onto the blockchain.  This is especially true on big-bad-public-blockchains (BBPB) like Bitcoin or Ethereum which were designed to allow anyone to upload new contract logic.  On the other hand, private blockchains and consortium blockchains that are more tightly managed may not need or even want arbitrary user-defined logic.&lt;/p&gt;

&lt;p&gt;One thing that developers will appreciate in Tendermint is how much easier it is to code contract logic natively at the blockchain level, rather than as a contract script on a virtual machine.  You should use the VM if you need to deploy the contract on a public blockchain such as Ethereum.  You should use the EVM if you don&amp;rsquo;t have systems programming experience, and you find that writing a solidity contract is easier than writing in Golang, or if your contract-logic is simple enough that you wouldn&amp;rsquo;t mind stepping over bytecode execution to debug your contract.  But for other applications where the former exceptions don&amp;rsquo;t apply, you probably want to write native code on Tendermint for a variety of reasons &amp;ndash; Golang&amp;rsquo;s language tooling is better so debugging is easier, it&amp;rsquo;s computationally more efficient by far, and it&amp;rsquo;s two less complex layers (one for the bytecode compiled language, and one for the VM itself) for already seasoned developers to have to deal with.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m not knocking on EVM development.  The Ethereum team did a great job inventing the EVM and developing a lot of theory behind turing-complete smart-contracts.  It&amp;rsquo;s necessary on a public blockchain like Ethereum.  So, if you want to port your EVM contract over to Tendermint, that&amp;rsquo;s easy.  On the other hand, if you want full control over your merkle-ized data structures (e.g. without the 32-by-32-byte restriction of the EVM&amp;rsquo;s patricia trie) then you can write your contract as a native transaction type on Tendermint.&lt;/p&gt;

&lt;h2 id=&#34;fin:1825e1740a61156b2d6c2c2a5daacec7&#34;&gt;Fin&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Go to &lt;a href=&#34;http://tendermint.com&#34;&gt;http://tendermint.com&lt;/a&gt; and sign up for the newsletter.&lt;/li&gt;
&lt;li&gt;Develop on Tendermint.&lt;/li&gt;
&lt;li&gt;Email us at hello@tendermint.com with your full name to join our Slack channel.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Sidechains without Pegging</title>
      <link>http://tendermint.com/posts/sidechains-without-pegging/</link>
      <pubDate>Tue, 25 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://tendermint.com/posts/sidechains-without-pegging/</guid>
      <description>&lt;p&gt;&lt;br/&gt;
There is an interesting debate happening between Bitcoin maximalists and the rest of the cryptocurrency community.&lt;/p&gt;

&lt;p&gt;First, BlockStream published Bitcoin maximalist paper on &lt;a href=&#34;http://www.blockstream.com/sidechains.pdf&#34;&gt;sidechains&lt;/a&gt;.
Then, Dominic of Pebble responded with due &lt;a href=&#34;http://blog.pebble.io/post/100702644738/on-sidechains-bitcoin-maximalism-and-freedom&#34;&gt;criticism&lt;/a&gt;.
Vitalik of Ethereum responded with &lt;a href=&#34;https://blog.ethereum.org/2014/11/20/bitcoin-maximalism-currency-platform-network-effects/&#34;&gt;more analysis&lt;/a&gt;.
And finally, Joel of Union Square Ventures wrote about a very &lt;a href=&#34;http://joel.mn/post/103546215249/the-blockchain-application-stack&#34;&gt;Bitcoin maximal world&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I’d like to add a few points to this conversation.&lt;/p&gt;

&lt;p&gt;First, let’s get this out of the way.  Metacoins like Counterparty are a nuisance for Bitcoin, regardless of the merits of the Counterparty protocol itself.  They benefit by taking advantage of the Bitcoin consensus network.  They bloat the block-chain space with transactions that aren’t relevant to other Bitcoin users.  The security of the Counterparty system is dependent on the security of Bitcoin’s, while it’s entirely possible that the market cap of assets in Counterparty become higher than that of Bitcoin, creating a lopsided security threat.  Metacoins will phase out as it becomes easier to bootstrap a secure coin with a pre-built consensus engine (such as Tendermint) that doesn’t rely on proof-of-work.  When the valuation of Bitcoin drops enough, Counterparty will be forced to migrate to its own block-chain too.&lt;/p&gt;

&lt;p&gt;The main thing I’d like to talk about is sidechains.  The term was first introduced by Bitcoin developers who were considering ways to encourage innovation in the alt-coin space while cutting down on the speculation and volatility that results from bootstrapping a new coin ex nihilo, by 1-way or 2-way pegging.  It works by having one block-chain track the consensus state of another block-chain.  It’s no wonder that the term “sidechain” refers to two distinct concepts — interchain-communication and pegging.  I like the term for its succinctness, so I’m going to try to hijack it to mean only interchain-communication — with or without pegging.&lt;/p&gt;

&lt;p&gt;The beautiful thing about sidechains is that it’s more than currency pegging.  For example, it can be used to run a decentralized exchange between two currencies.  You can do this now with “cross-chain-transactions”, but it requires both parties to be online, or for both to trust a few “smart oracles” with threshold signatures to handle the trade.  But when your block-chain can track the state of another with sidechain technology, you don’t have to trust anyone except the cryptocurrency network, which you trust already.  If you trust a block-chain enough to hold coins in it, you should trust the block-chain to enforce your exchange orders for you when you want to trade with a sidechain.  So now you can bootstrap a currency &lt;em&gt;and&lt;/em&gt; provide liquidity without trusted centralized exchanges, and really incentivize the development of new currencies without pegging the valuation onto &lt;s&gt;the Euro&lt;/s&gt;Bitcoin.  It’s especially important to have sovereign unpegged market-priced block-chains if the very thing you want to experiment with is monetary policy.&lt;/p&gt;

&lt;p&gt;Sidechain technology is more than 1-way or 2-way pegging to Bitcoin. It&amp;rsquo;s about contractual agreement between two communities represented by different consensus ledgers.  To pretend otherwise will only hurt the cryptocurrency movement.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The Security of Cryptocurrency Protocols</title>
      <link>http://tendermint.com/posts/security-of-cryptocurrency-protocols/</link>
      <pubDate>Wed, 19 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://tendermint.com/posts/security-of-cryptocurrency-protocols/</guid>
      <description>&lt;p&gt;&lt;br/&gt;
Many solutions to the consensus problem for cryptocurrencies have been proposed.  Since the innovation of Bitcoin’s proof-of-work based consensus algorithm&amp;ndash;where miners compete in an energy intensive game to determine the order of transactions&amp;ndash;several proof-of-stake algorithms have been proposed to make consensus faster while removing the reliance on energy expenditure.  The common objective of these protocols is to maintain a live decentralized transaction ledger while defending against double-spend attacks from malicious Byzantine actors deviating from the protocol.  Considering the financial nature of these protocols, we should strive to support a protocol that has well defined and robust security guarantees.&lt;/p&gt;

&lt;p&gt;The security analysis of cryptocurrency protocols is complicated by many factors.   One such complicating factor is the rational self-interested nature of participants.  The ideal protocol is an incentive aligned Nash equilibrium such that deviating from the protocol does not result in a net gain [&lt;a href=&#34;http://fc14.ifca.ai/papers/fc14_submission_82.pdf&#34;&gt;1&lt;/a&gt;, &lt;a href=&#34;https://www.cs.princeton.edu/~kroll/papers/weis13_bitcoin.pdf&#34;&gt;2&lt;/a&gt;].  This is a topic worthy of its own post, but won’t be discussed further here.&lt;/p&gt;

&lt;p&gt;Another complicating factor is whether the power to achieve or disrupt consensus is extrinsic in origin (e.g. access to the production of mining equipment or cheap access to electricity) or intrinsic in origin (e.g. the “stake” of validators in proof-of-stake protocols) and whether the disruption of consensus&amp;ndash;especially via a successful double-spend attack&amp;ndash;is associated with a commensurate penalty.  The problem with extrinsic factors of security is that they are not easily quantifiable for analysis.  For example, the depreciation costs of Bitcoin mining hardware in the event of a successful double-spend attack may not be significant compared to the running costs of electricity in mining.  On the other hand existing proof-of-stake protocols do not have a well defined intrinsic penalty for instigators of a double-spend attack.  This is commonly called, ironically, the “nothing at stake” problem.  Newer protocols like the BitShares delegated-proof-of-stake protocol attempt to address this problem by placing the role of ranked-delegate at stake, but security is dependant on the extrinsic ability of stakeholders to accurately predict the future performance of delegates.&lt;/p&gt;

&lt;p&gt;What is needed is a radical simplification.  Security analysis is much simpler for an intrinsically secure cryptocurrency protocol when it can be proved that launching a double-spend attack necessarily results in a very high intrinsic penalty compared to the possible intrinsic gains.  Then, the protocol may be considered resistant to double-spent attacks assuming no further extrinsic complications.&lt;/p&gt;

&lt;p&gt;For example, consider a protocol that requires stakeholders to first post a surety bond before becoming a validator to participate in the consensus process.  To get the bonded coins back, the validator must first submit an unbonding transaction and wait a fixed, relatively long duration of time.  The validator’s only duty until the unbonding period is over is to participate in the protocol while taking care not to sign two blocks at the same height: the only way to fork the block-chain.  The validator that signs duplicitously loses its bonded coins as evidence of duplicity is entered onto the block-chain.  This protocol might adapt an existing Byzantine consensus algorithm from academic research (e.g. one proposed by Dwork, et al. [&lt;a href=&#34;http://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf&#34;&gt;3&lt;/a&gt;]) to create a quorum of validators that agree on and sign the next block.  For a partially synchronous network (such as the Internet) at least two thirds of voting power is needed to agree on the next block, and up to one third of Byzantine voting power can be tolerated.  A double-spend attack implies a fork in the block-chain, which by simple arithmetic requires at least one third of voting power to have signed duplicitously.&lt;/p&gt;

&lt;p&gt;The above proposed protocol is secured by completely intrinsic means; it does not require a massive expenditure of energy to secure.  The total intrinsic penalty for successfully launching a double-spend attack (which is at least one third of all bonded coins as mentioned previously) can be adjusted by judiciously setting the incentives given to validators by way of fees or inflationary rewards.  The block-chain does not fork at all except in extraordinary circumstances, making it ideally suited for side-chain extensions.  It is to the my best knowledge the only completely decentralized cryptocurrency protocol that could be proven to be intrinsically incentive aligned.  Perhaps it is time to consider this kind of algorithm.&lt;/p&gt;

&lt;div class=&#34;credit&#34;&gt;
Links:
&lt;ol&gt;
    &lt;li&gt;Eyal and Sirer.  The Majority is Not Enough. 2014, http://fc14.ifca.ai/papers/fc14_submission_82.pdf&lt;/li&gt;
    &lt;li&gt;Kroll et al.  The Economics of Bitcoin Mining, or Bitcoin in the Presence of Adversaries. 2013, https://www.cs.princeton.edu/~kroll/papers/weis13_bitcoin.pdf&lt;/li&gt;
    &lt;li&gt;Dwork, Lynch, and Stockmeyer.  Consensus in the Presence of Partial Synchrony. 1988, http://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>